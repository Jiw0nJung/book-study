# 1. 서론

**운영체제**는 컴퓨터 하드웨어를 관리하는 소프트웨어입니다. 운영체제는 또한 응용 프로그램을 위한 기반을 제공하며 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행합니다.

## 1.1 운영체제가 할 일

![컴퓨터 시스템 구성요소에 대한 개략적 구성도](./image/img-1-1.png)

컴퓨터 시스템은 대개 네 가지 구성요소인 하드웨어, 운영체제, 응용 프로그램 및 사용자로 구분할 수 있습니다.

- **하드웨어:** 중앙 처리 장치(CPU), 메모리 및 입출력(I/O) 장치로 구성되어 기본 계산용 자원을 제공
- **응용 프로그램:** 사용자의 계산 문제를 해결하기 위해 이들 자원이 어떻게 사용될지를 정의합니다.
- **운영체제:** 사용자를 위해 다양한 응용 프로그램 간의 하드웨어 사용을 제어하고 조정합니다.

또한 우리는 컴퓨터 시스템이 하드웨어, 소프트웨어 및 데이터로 구성되어 있다고 볼 수 있습니다. 운영 체제는 컴퓨터 시스템이 동작할 때 이들 자원을 적절하게 사용할 수 있는 방법을 제공합니다.

### 1.1.1 사용자 관점

컴퓨터에 대한 사용자의 관점은 사용되는 인터페이스에 따라 달라집니다.

### 1.1.2 시스템 관점

컴퓨터 시스템은 문제를 해결하기 위해 요구되는 여러 가지 자원들을 가집니다. 운영체제는 컴퓨터 시스템을 효율적이고 공정하게 운영할 수 있도록 어느 요청에 자원을 홯당할지 결정하는 **자원 할당자**(Resource Allocator)로서 동작합니다. 또한 컴퓨터의 부적절한 사용을 방지하기 위해 입출력 장치와 사용자 프로그램을 제어하는 **제어 프로그램**입니다.

### 1.1.3 운영체제의 정의

일반적으로 운영체제에 대한 적합한 정의는 없습니다. 운영체제는 유용한 컴퓨팅 시스템을 만들기 위한 합리적인 방법을 제공하기 때문에 존재합니다. 프로그램에 필요한 자원을 제어하고 할당하는 일반적인 기능들이 운영체제라는 하나의 소프트웨어로 통합됩니다.

운영체제에 포함되는 요소에 보편적인 정의는 없습니다. 포함되는 기능은 시스템마다 크게 다릅니다. 일반적으로 필요한 운영체제를 컴퓨터에서 실행하는 프로그램인 **커널**과 함께 두 가지 다른 유형의 프로그램이 포함됩니다. 운영체제와 관련되어 있지만 반드시 커널의 일부일 필요는 없는 **시스템 프로그램**과 시스템 작동과 관련되지 않은 모든 프로그램을 포함하는 **응용 프로그램**입니다.

개인용 컴퓨터가 널리 보급되고 운영체제가 점점 정교해짐에 따라 운영체제의 구성 용소가 무엇인지 점점 중요해 졌습니다. 1998년 Microsoft는 너무 많은 기능을 포함하여 응용 프로그램 공급 업체의 경쟁을 막았다고 유죄를 선고받았습니다. (에를 들어, 웹 브라우저는 Microsoft 운영체제의 필수 요소입니다.) 그러나 오늘날 모바일 기기의 운영체제를 살펴보면 운영체제를 구성하는 기능의 수가 다시 증가하고 있습니다. 모바일 운영체제에는 종종 핵심 커널뿐만 아니라 **미들웨어**(응용 프로그램 개발자에게 추가 서비스를 제공하는 일련의 소프트웨어 프레임 워크)도 포함됩니다.

## 1.2 컴퓨터 시스템의 구성

![통상적인 PC 컴퓨터 시스템](./image/img-1-2.png)

현대의 범용 컴퓨터 시스템은 하나 이상의 CPU와 구성요소와 공유 메모리 사이의 객세스를 제공하는 공통 **버스**를 통해 연결된 여러 장치 컨트롤러로 구성됩니다. 각 장치 컨트롤러는 특정 유형의 장치를 담당하고, 컨트롤러에 따라 둘 이상의 장치가 연결될 수도 있습니다. 장치 컨트롤러는 일부 로컬 버퍼 저장소와 특수 목적 레지스터 집합을 유지 관리하는데, 장치 컨트롤러는 버퍼 저장소와 제어하는 장치 간에 데이터를 이동합니다.

일반적으로 운영체제에는 각 장치 컨트롤러마다 **장치 드라이버**가 있습니다. 이 장치 드라이버는 장치 컨트롤러의 작동을 알고 있고 나머지 운영체제의 장치에 대한 인터페이스를 제공합니다. CPU와 장치 컨트롤러는 병렬로 실행되며, 메모리 사이클을 놓고 경쟁합니다. 공유 메모리를 질서 있게 액세스하기 위해 메모리 컨트롤러는 메모리에 대한 액세스를 동기화합니다.

### 1.2.1 인터럽트(Interrupts)

일반적인 컴퓨터 작업(입출력을 수행하는 프로그램)을 생각해봅니다.

1. 입출력 작업을 시작하기 위해 장치 드러이버는 장치 컨트롤러의 적절한 레지스터에 값을 적재해야 합니다.
2. 장치 컨트롤러는 이러한 레지스터의 내용을 검사하여 수행할 작업을(키보드에서 문자 읽기) 결정합니다.
3. 컨트롤러는 장치에서 로컬 버퍼로 데이터 전송을 시작합니다. 데이터 전송이 완료되면 장치 컨트롤러는 장치 드라이버에게 작업이 완료되었음을 알립니다.
4. 읽기 요청이면 장치 드라이버는 데이터 또는 데이터에 대한 포인터를 반환하며 운영체제의 다른 부분에 제어를 넘깁니다.
5. 다른 작업의 경우 장치 드라이버는 "쓰기 완료" 또는 "장치 사용 중"과 같은 상태 정보를 반환합니다.

컨트롤러는 장치 드라이버에게 작업을 완료했다는 사실을 어떻게 알릴까요? 이는 **인터럽트**를 통해 이루어집니다.

#### 1.2.1.1 개요

각 컴퓨터 설계는 자신의 인터럽트를 메커니즘으로 가지고 있으며, 몇 가지 기능은 공통적입니다.

- 인터럽트는 적절한 서비스 루티으로 제어를 전달합니다.
- 임터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장해야 하며, 복귀하기 전에 그 상태를 복원해야 합니다.

#### 1.2.1.2 구현

![인터럽트 구동 방식의 입출력 사이클](./image/img-1-4.png)

장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트를 **발생**(raise) 시키고, CPU는 인터럽트를 **포착**(catch)하여 인터럽트 핸들러로 **디스패치**(dispatch)하고 핸들러는 장치를 서비스하여 인터럽트를 **지웁니다**(clear). 기본 인터럽트 기법은 장치 컨트롤러가 서비스할 준비가 될 때와 같은 비동기 이벤트에 CPU가 대응할 수 있게 합니다. 그러나 최신 운영체제에서는 더욱 정겨한 인터럽트 처리 기능이 필요합니다. 최신 컴퓨터 하드웨어에서 다음 세 가지 기능을 CPU 및 **인터럽트 컨트롤러 하드웨어**에서 제공헙니다.

1. 중요한 처리 중에 인터럽트 처리를 연기할 수 있어야 합니다.
2. 장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법이 필요합니다.
3. 운영체제가 우선순위가 높은 인터럽트와 우선순위가 낮은 인터럽트를 구분하고 적절히 대응할 수 있도록 다단계 인터럽트가 필요합니다.

대배분의 CPU에는 2개의 인터럽트 요청 라인이 있습니다. 하나는 복구할 수 없는 메모리 오류와 같은 이벤트를 위해 예약된 **마스크 불가능 인터럽트**(Nonmaskable Interrupt)입니다. 두번째는 장치 컨트롤라가 서비스를 요청하기 위해 사용하는 **마스크 가능 인터럽트**(Maskable)입니다. 마스크 가능 인터럽트는 인터럽트 되어서는 안되는 중요한 명령 시퀀스를 실행하기 전에 CPU에 의해 꺼질 수 있습니다.

**백터 방식 인터럽트 기법**의 목적은 하나의 인터럽트 핸들러가 가능한 모든 인터럽트 소스를 검색할 필요를 줄이기 위함입니다. 그러나 실제로 컴퓨터에는 인터럽트 백터의 주소 개수보다 더 많은 장치(따라서 인터럽트 핸들러)가 있습니다. 이 문제를 해결하는 일반적인 방법은 **인터럽트 체인**을 사용하는 것입니다. 인터럽트 백터의 각 원소는 인터럽트 핸들러 리스트의 헤드를 가리킵니다. 인터럽트가 발생하면 요청을 처리할 수 있는 핸들러가 발견될 때까지 상응하는 리스트의 핸들러가 하나씩 호출됩니다. 이러한 구조느 ㄴ큰 크기의 인터럽트 테이블 오버헤드와 하나의 인터럽트 핸들러로 디스패치 하는 비효율성의 절충안입니다.

인터럽트 기법은 또한 인터럽트 **우선순위 레벨**(Interrupt Priority Level)을 구현합니다. 이러한 레벨을 통해 CPU는 모든 인터럽트를 마스킹하지 않고도 우선순위가 낮은 인터럽트 처리를 연기할 수 있습니다.

### 1.2.2 저장장치 구조

CPU는 메모리에서만 명령을 적재할 수 있으므로 실행하려면 프로그램을 먼저 메모리에 적재해야 합니다. 범용 컴퓨터는 프로그램 대부분을 **메인 메모리**(Random Aceess Memory, RAM)라 불리는 재기로 까능한 메모리에서 가져옵니다. 컴퓨터는 다른 형태의 메모리도 사용합니다. 컴퓨터 전원을 켤 때 가장 먼저 실행되는 프로그램은 **부트스트랩 프로그램**이며 운영체제를 적재합니다. RAM은 **휘발성**이므로 브투스트랩 프로그램을 유지하는 용도로 사용할 수 없고, **EEPROM** 및 기타 형태의 **펌웨어**를 사용합니다. 이 메모리는 변경할 수는 있지만 자주 변경할 수는 없고, 속도가 느려서 정적 프로그램과 데이터를 포함합니다.

모든 형태의 메모리는 바이트 배열을 제공합니다. 각 바이트는 자신의 주소를 가지고 있습니다. 상호 작용은 특정 메모리 주소들에 대한 명령을 통해 이루어집니다.

- **적재 명령:** 메인 메모리로부터 CPU 내부의 레지스터로 한 바이트 또는 한 워드를 옮깁니다.
- **저장 명령:** 반대로 레지스터의 내용을 메인 메모리로 옮깁니다.

> **워드**는 그 컴퓨터 구조의 본연의 데이터 단위입니다. 한 워드는 하나 이상의 바이트로 구성됩니다. 예를 들면 64비트 레지트더들과 64비트 메모리 주소지정을 가지는 컴퓨터는 전형적으로 64비트 워드를 가집니다. 컴퓨터는 많은 연산을 한 번에 한 바이트 단위가 아니라 본연의 워드 단위로 실행합니다.

**폰 노이만 구조 시스템**에서 실행되는 전형적인 명령-실행 사이클은 다음과 같다.

1. 메모리로부터 명령을 인출해, 그 명령을 **명령 레지스터**에 저장합니다.
2. 명령을 해독하고 메모리로부터 피연산자를 인출하여 내부 레지스터에 저장합니다.
3. 피연산자에 대한 명령을 실행한 후에 결과가 메모리에 다시 저장됩니다.

이상적으로는, 프로그램과 데이터가 메인 메모리에 영구희 존재하기를 웒합니다. 그러나 이는 대부분의 시스템에서 두 가지 이유로 불가능합니다.

1. 메인 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 작습니다.
2. 메인 메모리는 이미 언급한 것처럼 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성 저장장치입니다.

그러므로 대부분의 컴퓨터 시스템은 메인 메모리의 확장으로 **보조저장장치**를 제공합니다. 보조저장장치의 주요 요건은 대량의 데이터를 영구히 보존할 수 있어야 한다는 점입니다. 가장 일반적인 보조저장장치는 **하드 디스크 드라이브**(HDD)와 **비휘발성 메모리 장치**(NVM)로, 프로그램과 데이터 모두를 위한 저장소를 제공합니다. 대부분의 프로그램(시스템 및 응용 프로그램)은 메모리에 적재될 때까지 보조저장장치에 저장됩니다. 캐시 메모리, CD-ROM 또는 Blu-ray, 자기 테이프등 자료의 백업 사본을 저장과 같은 특수 목적으로만 사용하기에, 매우 느리고 용량이 큰 저장장치를 **3차 저장장치**라고 합니다. 다양한 저장장치의 차이점은 속도, 크기 및 휘발성에 있습니다.

![저장장치 계층 구조](./image/img-1-6.png)

그림에서 최상위 4단계 메모리는 반도체 기반 전자회로로 구성된 **반도체 메모리**를 사용하여 구성됩니다. 네 번째 수준의 NVM 장치의 가장 일반적인 형태는 스마트폰 및 태블릿과 같은 모바일 장치에서 널리 사용되는 플래시 메모리입니다.

저장장치는 운영체제 구조에서 중요한 역할을 하기 때문에 교재에서 자주 참조할 것이기에 다음 용어를 사용할 것입니다.

- **메모리:** 휘발성 저장장치입니다.
- **NVS:** 전원이 꺼졌을 때 내용을 유지하는 비휘발성 보조저장장치입니다.
  - **기계적**(HDD, 광 디스크, 홀로그램) 저장장치는 일반적으로 전기적 저장장치보다 용량이 크고 바이트당 비용이 저렴합니다.
  - **전기적** 저장장치(플래시 메모리, FRAM, NRAM 및 SSD)는 일반적으로 기계적 저장장치보다 비싸고 용량이 적으며 빠릅니다. **NVM**으로 언급됩니다.

### 1.2.3 입출력 구조

![현대 컴퓨터의 작동 방식](./image/img-1-7.png)

1.2.1절에 설명된 인터럽트 구동 I/O의 형태는 소량의 데이터를 이동하는 데는 좋지만 NVS I/O와 같은 대량의 데이터 이동에 사용될 때 높은 오버헤드를 유발할 수 있습니다. 이 문제를 해결하기 위해 **직접 메모리 액세스**(DMA)가 사용됩니다. 장치에 대한 버퍼 및 포인터, 입출력 카운트를 세팅한 후 장치 제어기는 CPU의 개입 없이 메모리로부터 자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체를 전송합니다. 속도가 느린 장치처럼 한 바이트마다 인터럽트가 발생하는 것이 아니라 블록 전송이 완료될 때마다 인터럽트가 발생합니다. 장치 컨트롤러가 전송 작업을 수행하고 있는 동안 CPU는 다른 작업을 수행할 수 있습니다.

## 1.3 컴퓨터 시스템 구조

- **CPU:** 명령을 실행하는 하드웨어
- **프로세서:** 하나 이상의 CPU를 포함하는 물리적 칩
- **코어:** CPU 기본 계산 단위

### 1.3.1 단일 처리 시스템(Single Processor System)

몇 년 전, 대부분의 컴퓨터 시스템은 단일 코어를 가진 하나의 CPU를 포함하는 단일 프로세서를 사용했습니다. **코어**는 명령을 시행하고 로컬로 데이터를 저장하기 위한 레지스터를 포함하는 구성요소입니다. 이 시스템에는 다른 특수 목적의 전용 처리기를 가질 수 있습니다. 전용 처리기에는 디스크, 키보디 및 크래픽 컨트롤러와 같은 장치별 처리기가 있으며, 제한된 명령어 집합을 실행하고 사용자 프로세스를 실행하지 않습니다. 때로 이 처리기들은 운영체제에 의해 관리되기도 하는데, 운영체제는 이 처리기들이 수행할 다음 테스크에 대한 정보를 보내고 처리기들의 상태를 감시합니다.

### 1.3.2 다중 처리기 시스템(Multi Processor System)

모바일 장치에서 서버에 이르기까지 최신 컴퓨터에는 **다중 처리기 시스템**이 컴퓨팅 환경을 지배하고 있습니다. 일반적으로 이러한 시스템에는 각각 단일 코어 CPU가 있는 두개 이상의 프로세서가 있습니다. 프로세서들은 버스, 클록, 메모리 및 주변 장치를 공유합니다. 다중 처리기 시스템의 주요 장점은 처리량의 증갑입니다. 즉, 프로세서 수를 늘리면 더 적은 시간에 더 많은 작업을 수행할 수 있습니다. 그러나 N개의 프로셋서의 속도 향상 비율은 N이 아닙니다. 여러 프로세서가 하나의 작업에 협력할 때 모든 프로세서가 올바르게 작동하기 위해서 일정한 양의 오버헤드가 발생하기 때문입니다.

가장 일반적인 다중 처리기 시스템은 각 프로세서가 운영체제 기능 및 사용자 프로세스를 포함한 모든 작업을 대등하게 수행하는 **SMP**(Stmmentic Multiprocessing)를 사용합니다. 각 CPU 처리기에는 개별 또는 로컬 캐시뿐만 아니라 자체 레지스터 세트가 있습니다. 그러나 모둔 프로세서는 시스템 버스를 통해 물리 메모리를 공유합니다.

![대칭형 다중 처리 구조](./image/img-1-8.png)

이 모델의 장점은 많은 프로세스를 동시에 실행할 수 있다는 것입니다. N개의 CPU가 있으면 성능을 크게 저하하지 않으면서 N개의 프로세스를 실행할 수 있습니다. 그러나 CPU가 독립적이기 때문에 하나는 유휴 상태이고 다른 하나는 과부하가 걸려 비효율적일 수 있습니다.

**다중 처리기**의 정의는 시간이 지남에 따라 발전해 왔으며 이제는 여러 개의 컴퓨팅 코어가 단일 칩에 상주하는 **다중 코어** 시스템을 포함합니다. 칩 내 통신이 칩 간 통신보다 빠르므로 다중 코어 시스템은 단일 코어를 가지는 여러 칩보다 효율적일 수 있습니다. 또한 여러 개의 코어를 가지는 하나의 칩은 여러 개의 단일 코어 칩보다 훨씬 적은 전력을 사용하는데, 이는 노트북뿐만 아니라 모바일 장치에서 중요한 문제입니다. 이 설계에서 각 코어에는 자체 레지스터 세트와 레벨 1 (L1) 캐시하고도 하는 자체 로컬 캐시가 있습니다. 또한 레벨 2 (L2) 캐시는 칩에 국한되지만 두 처리 코어에서 공유합니다. 로컬 하위 레벨 캐시는 일반적으로 상위 레벨 공유 캐시보다 작고 빠릅니다.

![하나의 칩에 두 개의 코어를 가지는 이중-코어 설계](./image/img-1-9.png)

다중 처리기 시스템에 CPU를 추가하면 컴퓨팅 성능이 향상됩니다. 그러나 앞에서 제안한 것처럼 이러한 개념은 그다지 확장성이 좋지 않고, CPU를 너무 많이 추가하면 시스템 버스에 대한 경합에 병목 현상이 되어 성능이 저하되기 시작합니다. 다른 방법은 각 CPU(또는 CPU 그룹)에 작고 빠른 로컬 버스를 통해 엑세스 되는 자체 로컬 메모리를 제공하는 것입니다. CPU마다 하나의 로컬 메모리를 가지며, 모든 CPU가 **공유 시스템 연결**로 연결됩니다. **NUMA**(Non-uniform Memory Access)라고 하는 이 방법의 장점은 CPU가 로컬 메모리에 액세스 할 때 빠를 뿐만 아니라 시스템 상호 연결에 대한 경합도 없다는 것입니다. 따라서 NUMA 시스템은 더 많은 프로세서가 추가될수록 더 효과적으로 확장할 수 있습니다. NUMA의 시스템의 잠재적 단점은 CPU가 시스템 상호 연결을 통해 원격 메모리(다른 CPU의 로컬 메모리)에 액세스해야 할 때 지연 시간이 증가하여 성능 저하가 발생할 수 있다는 것입입니다.

![NUMA 다중 처리 구조](./image/img-1-10.png)

마지막으로 **블레이드 서버**는 다수의 처리기 보드 및 입출력 보드, 네트워킹 보드들이 하나의 **섀시**(chassis) 안에 장착되는 형태를 가집니다. 블레이드 서버와 전통적인 다중 처리기 시스템과의 차이점은 각 블레이드-처리기 보드는 독립적으로 부팅될 수 있고, 자기 자신의 운영체제를 수행한다는 것입니다. 어떤 블레이드-서버 보드는 자체가 다중 처리기이기도 하며, 이런 형태는 컴퓨터 유형 간의 유형 경계를 모호하게 만듭니다. 근본적으로 이 블레이드 서버는 여러 독립적인 다중 처리기 시스템으로 구성됩니다.
